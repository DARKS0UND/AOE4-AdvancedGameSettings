-- Authors:
-- Relic
-- Woprock
-- jackelpobelope (InternalCustomStartConditions_ScatteredVillagersStart)
--
-- Contains function that initialize player starting position.
-- Main mode must call CustomStartConditions_HandleStartPosition during PostInit and CustomStartConditions_OnStartContinuation during Start, might be registred as module later.
-- Requires custom_helpers.scar
--
--

-- PostInit() fake handler for now
function CustomStartConditions_HandleStartPosition(_match)
	--Starting type
	if _match.options.section_custom_conditions and 
	   _match.options.section_custom_conditions.option_start_type then 
		-- standard
		if _match.options.section_custom_conditions.option_start_type.enum_value == _match.options.section_custom_conditions.option_start_type.enum_items.standard then
			InternalCustomStartConditions_StandardStart(_match)
			InternalCustomStartConditions_RevealInitialMapArea(_match)
			-- Spawn each civilization squad
			InternalCustomStartConditions_SpawnInitialSquads()
		-- slow nomad
		elseif _match.options.section_custom_conditions.option_start_type.enum_value == _match.options.section_custom_conditions.option_start_type.enum_items.slow_nomad then
			InternalCustomStartConditions_SlowNomadStart(_match)
			-- Spawn each civilization squad
			InternalCustomStartConditions_SpawnInitialSquads()
		-- scattered villagers
		elseif _match.options.section_custom_conditions.option_start_type.enum_value == _match.options.section_custom_conditions.option_start_type.enum_items.scattered_villagers then
			InternalCustomStartConditions_ScatteredVillagersStart()		
		end		
	end
end

-- Start() fake handler for now
function CustomStartConditions_OnStartContinuation(_match)
	--Starting type
	if _match.options.section_custom_conditions and 
		_match.options.section_custom_conditions.option_start_type and 
		_match.options.section_custom_conditions.option_start_type.enum_value == _match.options.section_custom_conditions.option_start_type.enum_items.slow_nomad then
		InternalCustomStartConditions_SlowNomadOnStart(_match)
	end	
end

-- Setup initial TC or mongol moving TC
function InternalCustomStartConditions_StandardStart(_match)
	for i, player in pairs(PLAYERS) do			
		-- chinese dont work with this, most likely due to missing value in table for their capital TC
		--local townCenterEBP = Cardinal_ConvertTypeToEntityBlueprint({_match.types.townCenter, _match.types.landmark}, player.id)				
		
		local player_civ = Player_GetRaceName(player.id)
		
		local townCenterEBP = InternalCustomOptions_GetTownCenterCapital(player_civ)
		
		if (player_civ == "mongol") then
			local sqTownCenter = Player_GetSquadsFromType(player.id, _match.types.townCenter)
			if SGroup_Count(sqTownCenter) == 0 then	
				local moveableTownCenter = BP_GetSquadBlueprint("building_town_center_capital_moving_mon")
				local sgroup_name = "sg_player_town_center_" .. tostring(player.id)
				local sg_units = SGroup_CreateIfNotFound(sgroup_name)
				UnitEntry_DeploySquads(player.id, sg_units, {{sbp = moveableTownCenter, numSquads = 1 }}, player.startingPos)
				--SGroup_Add(sqTownCenter, moveableTownCenter)
			end
		else
			-- Create the initial (capital) town center, if necessary		
			local egTownCenter = Player_GetEntitiesFromType(player.id, _match.types.townCenter) 
			if EGroup_Count(egTownCenter) == 0 then			
				local townCenter = InternalCustomOptions_SpawnEntityAtSpawnOffset(player.id, townCenterEBP, 0, 0, 0)	
				EGroup_Add(egTownCenter, townCenter)
			end	
			-- Send event (conquest win condition relies on this)
			Core_CallDelegateFunctions("OnConstructionComplete", {pbg = townCenterEBP, player = player.id, entity = EGroup_GetEntityAt(egTownCenter, 1)})			
		end		
	end
end
-- Setup initial reveal for standard, other condition would be too easy with it.
function InternalCustomStartConditions_RevealInitialMapArea(_match)		
	-- Reveal fog of war
	for i, player in pairs(PLAYERS) do	
		if _match.FOWRevealRadius ~= nil then
			FOW_PlayerRevealArea(player.id, player.startingPos, _match.FOWRevealRadius, 0.25)		
		end
	end
end
-- Setup for some edge cases, this might be actually obsolate and could go.
function InternalCustomStartConditions_SlowNomadStart(_match)
	for i, player in pairs(PLAYERS) do		
		local player_civ = Player_GetRaceName(player.id)
		-- There will be no initial buildings for player ?
		Player_SetStateModelFloat(player.id, "has_capital", 0)
		-- Player should not build structures
		Player_SetStateModelBool(player.id, "player_can_construct_structures", true)
	end
end

-- Setup timers.
function InternalCustomStartConditions_SlowNomadOnStart(_match)
	-- time tracking data
	_custom.nomad.timeStarted = World_GetGameTime()
	_custom.nomad.timeThreshold = 0
	_custom.nomad.timeInterval = _custom.nomad.duration / _match.nomad.wood	
	
	InternalCustomStartConditions_ResetResources(_match)
end

-- Clear resources and continue with slow trickle.
function InternalCustomStartConditions_ResetResources(_match)
	
	for i, player in pairs(PLAYERS) do	
		
		-- Track resources remaining to provide
		player._nomadStart = { resources = {} }
		player._nomadStart.resources["Food"] = Player_GetResource(player.id, RT_Food)
		player._nomadStart.resources["Wood"] = Player_GetResource(player.id, RT_Wood)
		player._nomadStart.resources["Stone"] = Player_GetResource(player.id, RT_Stone)
		player._nomadStart.resources["Gold"] = Player_GetResource(player.id, RT_Gold)
		
		-- Adjust the difference needed for TC
		local player_civ = Player_GetRaceName(player.id)
		if player_civ == "mongol" then
			player._nomadStart.resources["Wood"] = player._nomadStart.resources["Wood"] + _match.nomad.wood
		else
			player._nomadStart.resources["Wood"] = player._nomadStart.resources["Wood"] + _match.nomad.wood
			player._nomadStart.resources["Stone"] = player._nomadStart.resources["Stone"] + _match.nomad.stone
		end
		
		-- Reset resources
		Player_ResetResource(player.id, RT_Food)
		Player_ResetResource(player.id, RT_Wood)
		Player_ResetResource(player.id, RT_Stone)
		Player_ResetResource(player.id, RT_Gold)									
	end
	
	Rule_Add(InternalCustomStartConditions_IncrementResources)
end

-- Rule that incrementally returns initial resources to players over time.
function InternalCustomStartConditions_IncrementResources()	
	
	if World_GetGameTime() - _custom.nomad.timeStarted >= _custom.nomad.timeThreshold then
		local allResourcesReceived = true
		
		for i, player in pairs(PLAYERS) do
		
			local _IncrementResource = function(resIndex, resType) 				
				if player._nomadStart.resources[resIndex] > 0 then
					if player._nomadStart.resources[resIndex] == 1 then
						Player_AddResource(player.id, resType, 1)
						player._nomadStart.resources[resIndex] = 0
					else
						Player_AddResource(player.id, resType, 1)
						player._nomadStart.resources[resIndex] = player._nomadStart.resources[resIndex] - 1						
					end
				end
			end
			
			_IncrementResource("Food", RT_Food)
			_IncrementResource("Wood", RT_Wood)
			_IncrementResource("Stone", RT_Stone)
			_IncrementResource("Gold", RT_Gold)	
			
			-- Stop when player has received all resources
			for k,v in pairs(player._nomadStart.resources) do
				if player._nomadStart.resources[k] > 0 then
					allResourcesReceived = false
				end
			end
		end		
		
		if allResourcesReceived then		
			InternalCustomStartConditions_ResourcesFinished()
		else
			_custom.nomad.timeThreshold = _custom.nomad.timeThreshold + _custom.nomad.timeInterval
		end		
	end	
end

-- Ends nomad start's incremental resource accumulation. Gives players remaining resources, if any.
function InternalCustomStartConditions_ResourcesFinished()

	if Rule_Exists(InternalCustomStartConditions_IncrementResources) then	
	
		Rule_Remove(InternalCustomStartConditions_IncrementResources)								
		
		for i, player in pairs(PLAYERS) do		
			Player_AddResource(player.id, RT_Food, player._nomadStart.resources["Food"])
			Player_AddResource(player.id, RT_Wood, player._nomadStart.resources["Wood"])
			Player_AddResource(player.id, RT_Stone, player._nomadStart.resources["Stone"])
			Player_AddResource(player.id, RT_Gold, player._nomadStart.resources["Gold"])
			player._nomadStart = nil	
		end					
	end
end


function InternalCustomStartConditions_SpawnInitialSquads()
	for i, player in pairs(PLAYERS) do
		local player_civ = Player_GetRaceName(player.id)
		
		local vil = InternalCustomOptions_GetVillager(player_civ)
		InternalCustomOptions_SpawnUnitAtSpawnOffset(player.id, vil, -10, 0, -10, "villager", 6)
		
		local sco = InternalCustomOptions_GetScout(player_civ)
		InternalCustomOptions_SpawnUnitAtSpawnOffset(player.id, sco, -12, 0, -12, "scout", 1)
		
		local shp = InternalCustomOptions_GetSheep(player_civ)
		InternalCustomOptions_SpawnUnitAtSpawnOffset(player.id, shp, -9, 0, -9, "sheep", 1)
	end
end


-- Called on match initialization before handing control to the player
function InternalCustomStartConditions_ScatteredVillagersStart()	
	for i, player in pairs(PLAYERS) do		
		player_civ = Player_GetRaceName(player.id)
		
		-- Increase starting resources to cover building a TC
		if player_civ == "mongol" then
			Player_GiftResource(player.id, RT_Wood, 400)
		else
			Player_GiftResource(player.id, RT_Wood, 400)
			Player_GiftResource(player.id, RT_Stone, 300)
		end
		
		-- Get Villager BP based on civ
		local sbp_villager = InternalCustomOptions_GetVillager(player_civ)
		
		-- Get spawn dimensions
		local radius = math.max(World_GetWidth(), World_GetLength())/1.8 -- 1.8 to try and tune villager spawn out from the middle of the map
		local map_center = World_Pos(0, 0, 0)
		
		-- Generate random location and spawn vils 
		local i = 0
		while i < _custom.scattered_villagers do
			-- Generate random spawn location
			
			local randx = World_GetRand(0-radius, radius)
			local randz = World_GetRand(0-radius, radius)
			
			--local rand_pos = Util_GetRandomPosition(map_center, radius, true)
			local height = World_GetHeightAt(randx, randz)
			local spawn_pos = World_Pos(randx, height, randz)
			-- Create villager squad and spawn at random location
			local sg_villager = SGroup_CreateIfNotFound("sg_villager" .. i .. tostring(player.id))
			UnitEntry_DeploySquads(player.id, sg_villager, {{sbp = sbp_villager, numSquads = 1 }}, spawn_pos)
			
			i = i + 1
		end		
	end
end	